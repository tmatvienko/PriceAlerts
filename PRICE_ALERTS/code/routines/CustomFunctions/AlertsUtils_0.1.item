package routines;
import java.util.List;
import java.util.concurrent.*;
import java.time.Instant;

/*
 * user specification: the function's comment should contain keys as follows: 1. write about the function's comment.but
 * it must be before the "{talendTypes}" key.
 * 
 * 2. {talendTypes} 's value must be talend Type, it is required . its value should be one of: String, char | Character,
 * long | Long, int | Integer, boolean | Boolean, byte | Byte, Date, double | Double, float | Float, Object, short |
 * Short
 * 
 * 3. {Category} define a category for the Function. it is required. its value is user-defined .
 * 
 * 4. {param} 's format is: {param} <type>[(<default value or closed list values>)] <name>[ : <comment>]
 * 
 * <type> 's value should be one of: string, int, list, double, object, boolean, long, char, date. <name>'s value is the
 * Function's parameter name. the {param} is optional. so if you the Function without the parameters. the {param} don't
 * added. you can have many parameters for the Function.
 * 
 * 5. {example} gives a example for the Function. it is optional.
 */


public class AlertsUtils {
	

	
	public static ConcurrentHashMap<Integer, AlertsUtils.StockCache> stockCacheMap = new ConcurrentHashMap<Integer, AlertsUtils.StockCache>();
	
	
	public static List<AlertLog> alertLog = new CopyOnWriteArrayList<AlertLog>();
	
	public static class StockCache {
		
		public Integer instrumentID;
		public String instrCode;
		public Double basePrice;
		public Double previousDayClosePrice;
		public Double tradePriceLastMin;
		
		public StockCache(Integer instrumentID, String instrCode, Double basePrice, Double previousDayClosePrice, Double tradePriceLastMin) {
			this.instrumentID = instrumentID;
			this.instrCode = instrCode;
			this.basePrice = basePrice;
			this.previousDayClosePrice = previousDayClosePrice;
			this.tradePriceLastMin = tradePriceLastMin;
			
		}
		
	}
	
	
	
	
	public static class AlertLog {
		
		public Integer alertLogID;
		public Integer alertConfigurationID;
		public Integer ruleID;
		public Integer ruleThresholdID;
		public Integer instrumentID;
		public String priceType;
		public Double basePrice;
		public Double basePricePrevious;
		public Double midPrice;
		public Double tradePrice;
		public Double previousDayClosePrice;
		public Double closePrice;
		public Instant alertTimestamp;
		public Instant createdOn;
		
		public AlertLog(Integer alertConfigurationID, Integer ruleID, Integer ruleThresholdID
								, Integer instrumentID, String priceType, Double basePrice, Double basePricePrevious
								, Double midPrice, Double tradePrice, Double previousDayClosePrice, Double closePrice
								, Instant alertTimestamp, Instant createdOn){
			this.alertConfigurationID = alertConfigurationID;
			this.ruleID = ruleID;
			this.ruleThresholdID = ruleThresholdID;
			this.instrumentID = instrumentID;
			this.priceType = priceType;
			this.basePrice = basePrice;
			this.basePricePrevious = basePricePrevious;
			this.midPrice = midPrice;
			this.tradePrice = tradePrice;
			this.previousDayClosePrice = previousDayClosePrice;
			this.closePrice = closePrice;
			this.alertTimestamp = alertTimestamp;
			this.createdOn = createdOn;
		}
		
		
	}
	
	public static synchronized void setStockCacheValue(Integer alertConfigurationID, StockCache stockCache)
	{
		stockCacheMap.put(alertConfigurationID, stockCache);
	}
	
	public static synchronized void updateStockCacheValue(Integer alertConfigurationID, StockCache stockCache)
	{
		AlertsUtils.StockCache pValue = stockCacheMap.get(alertConfigurationID);
		if (pValue != null) {
			stockCacheMap.computeIfPresent(alertConfigurationID, (k, v) -> stockCache);
		}
	}

	
	
	
	
	/*
	 * 
	 * 	public static class RuleThreshold {
		
		public boolean isAlert;
		public double thresholdValue;
		
		public RuleThreshold(boolean isAlert, double thresholdValue) {
			this.isAlert = isAlert;
			this.thresholdValue = thresholdValue;
		}
		
	}
	
	public static boolean isNullOrBlank(String s)
	{
	  return (s==null || s.trim().equals(""));
	}
	
	public static RuleThreshold getThresholdChanges(double oldPrice, double newPrice, String thresholds ) {
    	
		RuleThreshold result = new RuleThreshold(false, 0);
    	
    	double priceChange = Math.abs(getPriceChange(oldPrice, newPrice));
    	
    	if (priceChange != 0) {
	    	String[] tmpArr = thresholds.split(",");
	    	for (int i = tmpArr.length - 1; i >= 0; i--) {
	    		double thresValue = Double.valueOf(tmpArr[i]);
	    		if (priceChange >= thresValue) {
	    			result.thresholdValue = thresValue;
	    			if (priceChange > 0) {
	    				result.isAlert = true;
	    			}
	    			else {
	    				result.isAlert= false;
	    			}
	    			break;
	    		}
	    	}
    	}
    	
    	return result;
    	       
    }
	
	

	public static String[] getThresholds(Double oldPrice, Double newPrice, String thresholdsValue, String thresholdsDelay ) {
    	
		String[] result = new String[] { "0", "0", "0"};
    	
		Double priceChange = getPriceChange(oldPrice, newPrice);
    	if (priceChange != 0) {
	    	String[] tmpThresValue = thresholdsValue.split(",");
	    	String[] tmpThresDelay = thresholdsDelay.split(",");
	    	for (int i = tmpThresValue.length - 1; i >= 0; i--) {
	    		Double thresValue = Double.valueOf(tmpThresValue[i]);
	    		if (Math.abs(priceChange) >= thresValue) {
	    			result[1] = Double.toString(thresValue);
	    			result[2] = tmpThresDelay[i];
	    			if (priceChange > 0) {
	    				result[0] = "1";
	    			}
	    			else {
	    				result[0]= "-1";
	    			}
	    			break;
	    		}
	    	}
    	}
    	
    	return result;
    	       
    }

	public static Double getPriceChange(Double priceNum, Double priceDenum) {
		if (priceNum == null || priceDenum == null){
			return 0.00;
		}
		else {
			return ((priceNum - priceDenum) / priceNum) * 100;
		}
	}
	
	*/
	
	
}



